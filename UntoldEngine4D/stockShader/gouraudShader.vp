#version 300 es

in vec4 Vertex;
in vec3 Normal;
in vec2 TextureCoord;
in float MaterialIndex;
in vec4 Weights;
in vec4 BoneIndices;
in vec4 TangentVector;

uniform mat4 MVPMatrix;
uniform mat3 NormalMatrix;
uniform mat4 MVMatrix;
uniform mat4 ModelMatrix;
uniform mat4 LightShadowSpaceMatrix;
uniform float ShadowCurrentPass;
uniform vec4 PointLight;

uniform vec4 DiffuseMaterialColor[10];
uniform vec4 SpecularMaterialColor[10];
uniform float DiffuseMaterialIntensity[10];
uniform float SpecularMaterialIntensity[10];
uniform float SpecularMaterialHardness[10];
uniform vec3 CameraViewDirection;

//Armature Uniforms
uniform float HasArmature;
uniform mat4 BoneMatrix[30];


out vec4 shadowCoord;
out mediump vec4 lightPosition;
out mediump vec3 normalInViewSpace;
out mediump vec4 positionInViewSpace;
out mediump vec2 vVaryingTexCoords;

out lowp vec4 colorVarying;

vec4 gouraudShading(vec3 surfaceNormal, vec4 surfacePosition, vec4 lightPosition){

    //get the color index
    int colorIndex=int(MaterialIndex);

    //retrieve the material colors
    highp vec3 materialDiffuseColor=DiffuseMaterialColor[colorIndex].xyz;
    highp vec3 materialSpecularColor=SpecularMaterialColor[colorIndex].xyz;
    highp vec3 materialAmbientColor=vec3(0.1,0.1,0.1)*materialDiffuseColor;

    //get the light direction
    highp vec3 lightDirection=normalize(vec3(lightPosition));

    //compute normal,viewDirection, halfplane
    highp vec3 n=normalize(surfaceNormal);
    highp vec3 viewDirection=normalize(-CameraViewDirection);
    highp vec3 halfPlane=normalize(lightDirection+viewDirection);

    //compute the diffuse and specular factors
    highp float diffuseFactor=max(0.0,dot(n,lightDirection));
    highp float specularFactor=max(0.0,dot(n,halfPlane));

    if(specularFactor>0.0){

        //compute specular shininess factor
        //specularFactor=pow(specularFactor,SpecularMaterialHardness[colorIndex]);

    }

    //compute final color
    highp vec3 color=materialAmbientColor+diffuseFactor*materialDiffuseColor*DiffuseMaterialIntensity[colorIndex]+specularFactor*materialSpecularColor*SpecularMaterialIntensity[colorIndex];

    return vec4(color,1.0);

}


void main(void)
{

    //Making use of the TangentVector attribute to silence the GL_INVALID_VALUE error. 
    mediump vec4 dummy=TangentVector;

    if(ShadowCurrentPass==0.0){

        //if aramture exist, compute the shadow mapping
        if(HasArmature==1.0){

            mediump ivec4 iBones=ivec4(BoneIndices);
            mediump vec4 newVertex=vec4(0);

            mediump int boneIndicesArray[4];
            boneIndicesArray[0]=iBones.x;
            boneIndicesArray[1]=iBones.y;
            boneIndicesArray[2]=iBones.z;
            boneIndicesArray[3]=iBones.w;

            mediump float weightArray[4];
            weightArray[0]=Weights.x;
            weightArray[1]=Weights.y;
            weightArray[2]=Weights.z;
            weightArray[3]=Weights.w;

            for(int i=0;i<4;i++){

                newVertex+=(BoneMatrix[boneIndicesArray[i]]*Vertex)*weightArray[i];

            }

            gl_Position = LightShadowSpaceMatrix*ModelMatrix*newVertex;

        //if no armature exists, then do shadow mapping as normal
        }else{

            gl_Position = LightShadowSpaceMatrix*ModelMatrix*Vertex;

        }


    }else{

        lightPosition=PointLight;

        vVaryingTexCoords=TextureCoord;

        shadowCoord=LightShadowSpaceMatrix*ModelMatrix*Vertex;

        if(HasArmature==1.0){

            mediump ivec4 iBones=ivec4(BoneIndices);
            mediump vec4 newVertex=vec4(0);
            mediump vec3 newNormal=vec3(0);

            mediump int boneIndicesArray[4];
            boneIndicesArray[0]=iBones.x;
            boneIndicesArray[1]=iBones.y;
            boneIndicesArray[2]=iBones.z;
            boneIndicesArray[3]=iBones.w;

            mediump float weightArray[4];
            weightArray[0]=Weights.x;
            weightArray[1]=Weights.y;
            weightArray[2]=Weights.z;
            weightArray[3]=Weights.w;

            for(int i=0;i<4;i++){

                newVertex+=(BoneMatrix[boneIndicesArray[i]]*Vertex)*weightArray[i];
                newNormal+=vec3((BoneMatrix[boneIndicesArray[i]]*vec4(Normal,0.0))*weightArray[i]);

            }

            normalInViewSpace=NormalMatrix*newNormal;

            positionInViewSpace=MVMatrix*newVertex;

            colorVarying=gouraudShading(normalInViewSpace,positionInViewSpace,lightPosition);

            gl_Position = MVPMatrix * newVertex;


        }else{

            normalInViewSpace=NormalMatrix*Normal;

            positionInViewSpace=MVMatrix*Vertex;

            colorVarying=gouraudShading(normalInViewSpace,positionInViewSpace,lightPosition);

            gl_Position = MVPMatrix * Vertex;
        }



    }
}
