#version 300 es

in vec4 Vertex;
in vec3 Normal;
in vec2 TextureCoord;
in float MaterialIndex;

uniform mat4 MVPMatrix;
uniform mat3 NormalMatrix;
uniform mat4 MVMatrix;
uniform mat4 ModelMatrix;
uniform mat4 LightShadowSpaceMatrix;
uniform float ShadowCurrentPass;
uniform vec4 PointLight;

uniform vec4 DiffuseMaterialColor[10];
uniform vec4 SpecularMaterialColor[10];
uniform float DiffuseMaterialIntensity[10];
uniform float SpecularMaterialIntensity[10];
uniform float SpecularMaterialHardness[10];
uniform vec3 CameraViewDirection;

out vec4 shadowCoord;
out mediump vec4 lightPosition;
out mediump vec3 normalInViewSpace;
out mediump vec4 positionInViewSpace;
out mediump vec2 vVaryingTexCoords;

out lowp vec4 colorVarying;

vec4 gouraudShading(vec3 surfaceNormal, vec4 surfacePosition, vec4 lightPosition){

    //get the color index
    int colorIndex=int(MaterialIndex);

    //retrieve the material colors
    highp vec3 materialDiffuseColor=DiffuseMaterialColor[colorIndex].xyz;
    highp vec3 materialSpecularColor=SpecularMaterialColor[colorIndex].xyz;
    highp vec3 materialAmbientColor=vec3(0.1,0.1,0.1)*materialDiffuseColor;

    //get the light direction
    highp vec3 lightDirection=normalize(vec3(lightPosition));

    //compute normal,viewDirection, halfplane
    highp vec3 n=normalize(surfaceNormal);
    highp vec3 viewDirection=normalize(-CameraViewDirection);
    highp vec3 halfPlane=normalize(lightDirection+viewDirection);

    //compute the diffuse and specular factors
    highp float diffuseFactor=max(0.0,dot(n,lightDirection));
    highp float specularFactor=max(0.0,dot(n,halfPlane));

    //compute specular shininess factor
    specularFactor=pow(specularFactor,SpecularMaterialHardness[colorIndex]);

    //compute final color
    highp vec3 color=materialAmbientColor+diffuseFactor*materialDiffuseColor*DiffuseMaterialIntensity[colorIndex]+specularFactor*materialSpecularColor*SpecularMaterialIntensity[colorIndex];

    return vec4(color,1.0);

}


void main(void)
{

    if(ShadowCurrentPass==0.0){

    gl_Position = LightShadowSpaceMatrix*ModelMatrix*Vertex;


    }else{

        lightPosition=PointLight;

        vVaryingTexCoords=TextureCoord;

        shadowCoord=LightShadowSpaceMatrix*ModelMatrix*Vertex;

        normalInViewSpace=NormalMatrix*Normal;

        positionInViewSpace=MVMatrix*Vertex;

        colorVarying=gouraudShading(normalInViewSpace,positionInViewSpace,lightPosition);

        gl_Position = MVPMatrix * Vertex;

    }
}